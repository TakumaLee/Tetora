package main

import (
	"context"
	"encoding/json"
	"os"
	"regexp"
	"strings"
	"testing"
	"time"
)

// --- newUUID tests ---

func TestNewUUID_NonEmpty(t *testing.T) {
	id := newUUID()
	if id == "" {
		t.Fatal("newUUID() returned empty string")
	}
}

func TestNewUUID_Unique(t *testing.T) {
	seen := make(map[string]bool)
	for i := 0; i < 100; i++ {
		id := newUUID()
		if seen[id] {
			t.Fatalf("newUUID() returned duplicate: %s", id)
		}
		seen[id] = true
	}
}

func TestNewUUID_Format(t *testing.T) {
	// UUID v4 pattern: xxxxxxxx-xxxx-4xxx-[89ab]xxx-xxxxxxxxxxxx
	pattern := regexp.MustCompile(`^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$`)
	for i := 0; i < 50; i++ {
		id := newUUID()
		if !pattern.MatchString(id) {
			t.Fatalf("newUUID() = %q does not match UUID v4 pattern", id)
		}
	}
}

// --- fillDefaults tests ---

func newTestConfig() *Config {
	return &Config{
		DefaultModel:          "sonnet",
		DefaultTimeout:        "15m",
		DefaultBudget:         5.0,
		DefaultPermissionMode: "acceptEdits",
	}
}

func TestFillDefaults_EmptyTask(t *testing.T) {
	cfg := newTestConfig()
	task := &Task{}
	fillDefaults(cfg, task)

	if task.ID == "" {
		t.Error("expected ID to be auto-generated")
	}
	if task.SessionID == "" {
		t.Error("expected SessionID to be auto-generated")
	}
	if task.Model != "sonnet" {
		t.Errorf("Model = %q, want %q", task.Model, "sonnet")
	}
	if task.Timeout != "15m" {
		t.Errorf("Timeout = %q, want %q", task.Timeout, "15m")
	}
	if task.Budget != 5.0 {
		t.Errorf("Budget = %v, want %v", task.Budget, 5.0)
	}
	if task.PermissionMode != "acceptEdits" {
		t.Errorf("PermissionMode = %q, want %q", task.PermissionMode, "acceptEdits")
	}
}

func TestFillDefaults_PresetFieldsPreserved(t *testing.T) {
	cfg := newTestConfig()
	task := &Task{
		ID:             "my-id",
		SessionID:      "my-session",
		Name:           "my-task",
		Model:          "opus",
		Timeout:        "30m",
		Budget:         10.0,
		PermissionMode: "bypassPermissions",
	}
	fillDefaults(cfg, task)

	if task.ID != "my-id" {
		t.Errorf("ID = %q, want %q", task.ID, "my-id")
	}
	if task.SessionID != "my-session" {
		t.Errorf("SessionID = %q, want %q", task.SessionID, "my-session")
	}
	if task.Name != "my-task" {
		t.Errorf("Name = %q, want %q", task.Name, "my-task")
	}
	if task.Model != "opus" {
		t.Errorf("Model = %q, want %q", task.Model, "opus")
	}
	if task.Timeout != "30m" {
		t.Errorf("Timeout = %q, want %q", task.Timeout, "30m")
	}
	if task.Budget != 10.0 {
		t.Errorf("Budget = %v, want %v", task.Budget, 10.0)
	}
	if task.PermissionMode != "bypassPermissions" {
		t.Errorf("PermissionMode = %q, want %q", task.PermissionMode, "bypassPermissions")
	}
}

func TestFillDefaults_IDAndSessionIDAutoGenerated(t *testing.T) {
	cfg := newTestConfig()
	task := &Task{}
	fillDefaults(cfg, task)

	if task.ID == "" {
		t.Error("expected ID to be auto-generated")
	}
	if task.SessionID == "" {
		t.Error("expected SessionID to be auto-generated")
	}
	if task.ID == task.SessionID {
		t.Error("ID and SessionID should be different UUIDs")
	}
}

func TestFillDefaults_WorkdirTildeExpansion(t *testing.T) {
	cfg := newTestConfig()
	task := &Task{Workdir: "~/projects/test"}
	fillDefaults(cfg, task)

	home, _ := os.UserHomeDir()
	if strings.HasPrefix(task.Workdir, "~/") {
		t.Errorf("Workdir still has ~/: %q", task.Workdir)
	}
	if !strings.HasPrefix(task.Workdir, home) {
		t.Errorf("Workdir = %q, expected prefix %q", task.Workdir, home)
	}
	if !strings.HasSuffix(task.Workdir, "projects/test") {
		t.Errorf("Workdir = %q, expected suffix %q", task.Workdir, "projects/test")
	}
}

func TestFillDefaults_EmptyNameAutoGenerated(t *testing.T) {
	cfg := newTestConfig()
	task := &Task{}
	fillDefaults(cfg, task)

	expectedPrefix := "task-" + task.ID[:8]
	if task.Name != expectedPrefix {
		t.Errorf("Name = %q, want %q", task.Name, expectedPrefix)
	}
}

func TestFillDefaults_DefaultWorkdirFromConfig(t *testing.T) {
	cfg := newTestConfig()
	cfg.DefaultWorkdir = "/tmp/tetora-test-workdir"
	task := &Task{}
	fillDefaults(cfg, task)

	if task.Workdir != "/tmp/tetora-test-workdir" {
		t.Errorf("Workdir = %q, want %q", task.Workdir, "/tmp/tetora-test-workdir")
	}
}

// --- parseClaudeOutput tests ---

func TestParseClaudeOutput_SuccessJSON(t *testing.T) {
	co := claudeOutput{
		Type:       "result",
		Result:     "Task completed successfully.",
		IsError:    false,
		DurationMs: 5000,
		CostUSD:    0.12,
		SessionID:  "sess-abc",
	}
	stdout, _ := json.Marshal(co)

	r := parseClaudeOutput(stdout, nil, 0)

	if r.Status != "success" {
		t.Errorf("Status = %q, want %q", r.Status, "success")
	}
	if r.Output != "Task completed successfully." {
		t.Errorf("Output = %q, want %q", r.Output, "Task completed successfully.")
	}
	if r.CostUSD != 0.12 {
		t.Errorf("CostUSD = %v, want %v", r.CostUSD, 0.12)
	}
	if r.SessionID != "sess-abc" {
		t.Errorf("SessionID = %q, want %q", r.SessionID, "sess-abc")
	}
	if r.Error != "" {
		t.Errorf("Error = %q, want empty", r.Error)
	}
	if r.ExitCode != 0 {
		t.Errorf("ExitCode = %d, want 0", r.ExitCode)
	}
}

func TestParseClaudeOutput_ErrorJSON(t *testing.T) {
	co := claudeOutput{
		Type:    "result",
		Subtype: "rate_limit",
		Result:  "Rate limited",
		IsError: true,
		CostUSD: 0.01,
	}
	stdout, _ := json.Marshal(co)

	r := parseClaudeOutput(stdout, nil, 0)

	if r.Status != "error" {
		t.Errorf("Status = %q, want %q", r.Status, "error")
	}
	if r.Error != "rate_limit" {
		t.Errorf("Error = %q, want %q", r.Error, "rate_limit")
	}
	if r.Output != "Rate limited" {
		t.Errorf("Output = %q, want %q", r.Output, "Rate limited")
	}
}

func TestParseClaudeOutput_InvalidJSONFallback(t *testing.T) {
	stdout := []byte("some raw text output")

	r := parseClaudeOutput(stdout, nil, 0)

	if r.Status != "success" {
		t.Errorf("Status = %q, want %q", r.Status, "success")
	}
	if r.Output != "some raw text output" {
		t.Errorf("Output = %q, want %q", r.Output, "some raw text output")
	}
}

func TestParseClaudeOutput_NonZeroExitInvalidJSON(t *testing.T) {
	stdout := []byte("partial output")
	stderr := []byte("something went wrong")

	r := parseClaudeOutput(stdout, stderr, 1)

	if r.Status != "error" {
		t.Errorf("Status = %q, want %q", r.Status, "error")
	}
	if r.ExitCode != 1 {
		t.Errorf("ExitCode = %d, want 1", r.ExitCode)
	}
	if r.Output != "partial output" {
		t.Errorf("Output = %q, want %q", r.Output, "partial output")
	}
	if r.Error != "something went wrong" {
		t.Errorf("Error = %q, want %q", r.Error, "something went wrong")
	}
}

func TestParseClaudeOutput_LongStderrTruncated(t *testing.T) {
	stdout := []byte("out")
	stderr := []byte(strings.Repeat("x", 600))

	r := parseClaudeOutput(stdout, stderr, 1)

	if len(r.Error) != 500 {
		t.Errorf("Error length = %d, want 500 (truncated)", len(r.Error))
	}
}

func TestParseClaudeOutput_EmptyStdout(t *testing.T) {
	r := parseClaudeOutput(nil, nil, 0)

	if r.Status != "success" {
		t.Errorf("Status = %q, want %q", r.Status, "success")
	}
	if r.Output != "" {
		t.Errorf("Output = %q, want empty", r.Output)
	}
}

func TestParseClaudeOutput_ValidJSONIgnoresExitCode(t *testing.T) {
	// When JSON is valid, the parsed status takes precedence.
	co := claudeOutput{
		Type:    "result",
		Result:  "done",
		IsError: false,
		CostUSD: 0.05,
	}
	stdout, _ := json.Marshal(co)

	r := parseClaudeOutput(stdout, []byte("some stderr"), 1)

	// Valid JSON means we use the JSON-parsed status, which is success.
	if r.Status != "success" {
		t.Errorf("Status = %q, want %q", r.Status, "success")
	}
	if r.ExitCode != 1 {
		t.Errorf("ExitCode = %d, want 1", r.ExitCode)
	}
}

// --- buildSummary tests ---

func TestBuildSummary_AllSuccess(t *testing.T) {
	dr := &DispatchResult{
		DurationMs: 5000,
		TotalCost:  0.25,
		Tasks: []TaskResult{
			{Status: "success", CostUSD: 0.10},
			{Status: "success", CostUSD: 0.15},
		},
	}
	summary := buildSummary(dr)

	if !strings.Contains(summary, "2/2") {
		t.Errorf("summary = %q, expected to contain %q", summary, "2/2")
	}
	if !strings.Contains(summary, "$0.25") {
		t.Errorf("summary = %q, expected to contain %q", summary, "$0.25")
	}
	if !strings.Contains(summary, "5s") {
		t.Errorf("summary = %q, expected to contain %q", summary, "5s")
	}
}

func TestBuildSummary_MixedResults(t *testing.T) {
	dr := &DispatchResult{
		DurationMs: 12800,
		TotalCost:  0.50,
		Tasks: []TaskResult{
			{Status: "success", CostUSD: 0.20},
			{Status: "error", CostUSD: 0.10},
			{Status: "timeout", CostUSD: 0.20},
		},
	}
	summary := buildSummary(dr)

	if !strings.Contains(summary, "1/3") {
		t.Errorf("summary = %q, expected to contain %q", summary, "1/3")
	}
	if !strings.Contains(summary, "$0.50") {
		t.Errorf("summary = %q, expected to contain %q", summary, "$0.50")
	}
	if !strings.Contains(summary, "13s") {
		t.Errorf("summary = %q, expected to contain %q", summary, "13s")
	}
}

func TestBuildSummary_NoTasks(t *testing.T) {
	dr := &DispatchResult{
		DurationMs: 100,
		TotalCost:  0.0,
		Tasks:      []TaskResult{},
	}
	summary := buildSummary(dr)

	if !strings.Contains(summary, "0/0") {
		t.Errorf("summary = %q, expected to contain %q", summary, "0/0")
	}
}

func TestBuildSummary_AllFailed(t *testing.T) {
	dr := &DispatchResult{
		DurationMs: 3000,
		TotalCost:  0.10,
		Tasks: []TaskResult{
			{Status: "error"},
			{Status: "error"},
		},
	}
	summary := buildSummary(dr)

	if !strings.Contains(summary, "0/2") {
		t.Errorf("summary = %q, expected to contain %q", summary, "0/2")
	}
}

// --- newDispatchState tests ---

func TestNewDispatchState(t *testing.T) {
	s := newDispatchState()
	if s == nil {
		t.Fatal("newDispatchState() returned nil")
	}
	if s.running == nil {
		t.Error("running map should be initialized")
	}
	if s.active {
		t.Error("new state should not be active")
	}
	if len(s.finished) != 0 {
		t.Error("new state should have no finished tasks")
	}
}

// --- dispatchState.statusJSON tests ---

func TestStatusJSON_Idle(t *testing.T) {
	s := newDispatchState()
	b := s.statusJSON()

	var out map[string]any
	if err := json.Unmarshal(b, &out); err != nil {
		t.Fatalf("statusJSON returned invalid JSON: %v", err)
	}
	if out["status"] != "idle" {
		t.Errorf("status = %q, want %q", out["status"], "idle")
	}
}

func TestStatusJSON_Done(t *testing.T) {
	s := newDispatchState()
	s.finished = []TaskResult{
		{ID: "abc", Name: "test", Status: "success"},
	}
	b := s.statusJSON()

	var out map[string]any
	if err := json.Unmarshal(b, &out); err != nil {
		t.Fatalf("statusJSON returned invalid JSON: %v", err)
	}
	if out["status"] != "done" {
		t.Errorf("status = %q, want %q", out["status"], "done")
	}
	completed, ok := out["completed"].(float64)
	if !ok || completed != 1 {
		t.Errorf("completed = %v, want 1", out["completed"])
	}
}

// --- sanitizePrompt tests ---

func TestSanitizePrompt_NullBytes(t *testing.T) {
	input := "hello\x00world"
	got := sanitizePrompt(input, 0)
	if strings.Contains(got, "\x00") {
		t.Error("sanitizePrompt should strip null bytes")
	}
	if got != "helloworld" {
		t.Errorf("sanitizePrompt = %q, want %q", got, "helloworld")
	}
}

func TestSanitizePrompt_ANSIEscapes(t *testing.T) {
	input := "hello \x1b[31mred\x1b[0m world"
	got := sanitizePrompt(input, 0)
	if got != "hello red world" {
		t.Errorf("sanitizePrompt = %q, want %q", got, "hello red world")
	}
}

func TestSanitizePrompt_MaxLength(t *testing.T) {
	input := strings.Repeat("a", 200)
	got := sanitizePrompt(input, 100)
	if len(got) != 100 {
		t.Errorf("sanitizePrompt length = %d, want 100", len(got))
	}
}

func TestSanitizePrompt_DefaultMaxLength(t *testing.T) {
	input := strings.Repeat("a", 200000)
	got := sanitizePrompt(input, 0)
	if len(got) != 102400 {
		t.Errorf("sanitizePrompt default max = %d, want 102400", len(got))
	}
}

func TestSanitizePrompt_CleanInput(t *testing.T) {
	input := "Normal prompt text with no special chars."
	got := sanitizePrompt(input, 0)
	if got != input {
		t.Errorf("sanitizePrompt should not modify clean input")
	}
}

func TestSanitizePrompt_Empty(t *testing.T) {
	got := sanitizePrompt("", 0)
	if got != "" {
		t.Errorf("sanitizePrompt(\"\") = %q, want \"\"", got)
	}
}

func TestSanitizePrompt_ComplexANSI(t *testing.T) {
	// Various ANSI sequences.
	input := "\x1b[1mbold\x1b[0m \x1b[38;5;200mcolor\x1b[0m"
	got := sanitizePrompt(input, 0)
	if strings.Contains(got, "\x1b") {
		t.Errorf("sanitizePrompt should strip all ANSI: %q", got)
	}
}

func TestStatusJSON_Dispatching(t *testing.T) {
	s := newDispatchState()
	s.active = true
	s.startAt = time.Now()
	s.running["test-id"] = &taskState{
		task:    Task{ID: "test-id-1234", Name: "running-task", Model: "opus", Timeout: "10m"},
		startAt: time.Now(),
	}
	b := s.statusJSON()

	var out map[string]any
	if err := json.Unmarshal(b, &out); err != nil {
		t.Fatalf("statusJSON returned invalid JSON: %v", err)
	}
	if out["status"] != "dispatching" {
		t.Errorf("status = %q, want %q", out["status"], "dispatching")
	}
	running, ok := out["running"].(float64)
	if !ok || running != 1 {
		t.Errorf("running = %v, want 1", out["running"])
	}
	if _, exists := out["elapsed"]; !exists {
		t.Error("expected elapsed field when dispatching")
	}
}

// --- failedTask tests ---

func TestNewDispatchState_FailedTasksInitialized(t *testing.T) {
	s := newDispatchState()
	if s.failedTasks == nil {
		t.Error("failedTasks map should be initialized")
	}
	if len(s.failedTasks) != 0 {
		t.Error("failedTasks map should be empty")
	}
}

func TestListFailedTasks_Empty(t *testing.T) {
	s := newDispatchState()
	tasks := listFailedTasks(s)
	if len(tasks) != 0 {
		t.Errorf("listFailedTasks on empty state = %d, want 0", len(tasks))
	}
}

func TestListFailedTasks_WithEntries(t *testing.T) {
	s := newDispatchState()
	s.failedTasks["task-1"] = &failedTask{
		task:     Task{ID: "task-1", Name: "failed-job", Prompt: "do something", Role: "琉璃", Source: "route:telegram"},
		failedAt: time.Now(),
		errorMsg: "rate limited",
	}
	s.failedTasks["task-2"] = &failedTask{
		task:     Task{ID: "task-2", Name: "timeout-job", Prompt: "do something else", Source: "dispatch"},
		failedAt: time.Now(),
		errorMsg: "timed out after 5m",
	}

	tasks := listFailedTasks(s)
	if len(tasks) != 2 {
		t.Errorf("listFailedTasks = %d entries, want 2", len(tasks))
	}

	// Check fields are populated.
	found := false
	for _, ft := range tasks {
		if ft.ID == "task-1" {
			found = true
			if ft.Name != "failed-job" {
				t.Errorf("Name = %q, want %q", ft.Name, "failed-job")
			}
			if ft.Role != "琉璃" {
				t.Errorf("Role = %q, want %q", ft.Role, "琉璃")
			}
			if ft.Error != "rate limited" {
				t.Errorf("Error = %q, want %q", ft.Error, "rate limited")
			}
			if ft.FailedAt == "" {
				t.Error("FailedAt should not be empty")
			}
		}
	}
	if !found {
		t.Error("task-1 not found in listFailedTasks output")
	}
}

func TestListFailedTasks_PromptTruncated(t *testing.T) {
	s := newDispatchState()
	longPrompt := strings.Repeat("a", 200)
	s.failedTasks["task-1"] = &failedTask{
		task:     Task{ID: "task-1", Name: "test", Prompt: longPrompt},
		failedAt: time.Now(),
		errorMsg: "error",
	}

	tasks := listFailedTasks(s)
	if len(tasks) != 1 {
		t.Fatalf("expected 1 task, got %d", len(tasks))
	}
	if len(tasks[0].Prompt) > 104 { // 100 + "..."
		t.Errorf("prompt should be truncated, got length %d", len(tasks[0].Prompt))
	}
}

func TestCleanupFailedTasks_RemovesExpired(t *testing.T) {
	s := newDispatchState()

	// Add a fresh task.
	s.failedTasks["fresh"] = &failedTask{
		task:     Task{ID: "fresh", Name: "fresh-task"},
		failedAt: time.Now(),
		errorMsg: "error",
	}

	// Add an expired task (31 minutes ago).
	s.failedTasks["expired"] = &failedTask{
		task:     Task{ID: "expired", Name: "expired-task"},
		failedAt: time.Now().Add(-31 * time.Minute),
		errorMsg: "old error",
	}

	cleanupFailedTasks(s)

	if _, ok := s.failedTasks["fresh"]; !ok {
		t.Error("fresh task should still exist after cleanup")
	}
	if _, ok := s.failedTasks["expired"]; ok {
		t.Error("expired task should be removed after cleanup")
	}
}

func TestCleanupFailedTasks_KeepsNonExpired(t *testing.T) {
	s := newDispatchState()

	// Add tasks at various ages below the TTL.
	s.failedTasks["t1"] = &failedTask{
		task:     Task{ID: "t1"},
		failedAt: time.Now().Add(-5 * time.Minute),
		errorMsg: "e",
	}
	s.failedTasks["t2"] = &failedTask{
		task:     Task{ID: "t2"},
		failedAt: time.Now().Add(-29 * time.Minute),
		errorMsg: "e",
	}

	cleanupFailedTasks(s)

	if len(s.failedTasks) != 2 {
		t.Errorf("cleanup removed non-expired tasks: got %d, want 2", len(s.failedTasks))
	}
}

func TestRetryTask_NotFound(t *testing.T) {
	s := newDispatchState()
	cfg := newTestConfig()

	sem := make(chan struct{}, 1)
	_, err := retryTask(context.Background(), cfg, "nonexistent", s, sem)
	if err == nil {
		t.Fatal("expected error for non-existent task")
	}
	if !strings.Contains(err.Error(), "not found") {
		t.Errorf("error = %q, want to contain 'not found'", err.Error())
	}
}

func TestRerouteTask_NotFound(t *testing.T) {
	s := newDispatchState()
	cfg := newTestConfig()
	cfg.SmartDispatch.Enabled = true

	sem := make(chan struct{}, 1)
	_, err := rerouteTask(context.Background(), cfg, "nonexistent", s, sem)
	if err == nil {
		t.Fatal("expected error for non-existent task")
	}
	if !strings.Contains(err.Error(), "not found") {
		t.Errorf("error = %q, want to contain 'not found'", err.Error())
	}
}

func TestRerouteTask_SmartDispatchDisabled(t *testing.T) {
	s := newDispatchState()
	cfg := newTestConfig()
	cfg.SmartDispatch.Enabled = false

	// Add a failed task.
	s.failedTasks["task-1"] = &failedTask{
		task:     Task{ID: "task-1", Name: "test", Prompt: "do something"},
		failedAt: time.Now(),
		errorMsg: "error",
	}

	sem := make(chan struct{}, 1)
	_, err := rerouteTask(context.Background(), cfg, "task-1", s, sem)
	if err == nil {
		t.Fatal("expected error when smart dispatch is disabled")
	}
	if !strings.Contains(err.Error(), "not enabled") {
		t.Errorf("error = %q, want to contain 'not enabled'", err.Error())
	}
}

func TestFailedTaskInfo_JSONSerialization(t *testing.T) {
	info := failedTaskInfo{
		ID:       "abc-123",
		Name:     "test-task",
		Prompt:   "do something",
		Role:     "琉璃",
		Source:   "telegram",
		Error:    "timed out",
		FailedAt: "2026-02-22T10:00:00Z",
	}

	data, err := json.Marshal(info)
	if err != nil {
		t.Fatalf("json.Marshal failed: %v", err)
	}

	var decoded failedTaskInfo
	if err := json.Unmarshal(data, &decoded); err != nil {
		t.Fatalf("json.Unmarshal failed: %v", err)
	}

	if decoded.ID != info.ID {
		t.Errorf("ID = %q, want %q", decoded.ID, info.ID)
	}
	if decoded.Name != info.Name {
		t.Errorf("Name = %q, want %q", decoded.Name, info.Name)
	}
	if decoded.Role != info.Role {
		t.Errorf("Role = %q, want %q", decoded.Role, info.Role)
	}
	if decoded.Error != info.Error {
		t.Errorf("Error = %q, want %q", decoded.Error, info.Error)
	}
	if decoded.FailedAt != info.FailedAt {
		t.Errorf("FailedAt = %q, want %q", decoded.FailedAt, info.FailedAt)
	}
}

// --- P21.2: loadWritingStyle tests ---

func TestLoadWritingStyle_FromFile(t *testing.T) {
	tmpFile, err := os.CreateTemp("", "style-*.txt")
	if err != nil {
		t.Fatal(err)
	}
	defer os.Remove(tmpFile.Name())

	content := "Write in a casual, friendly tone.\nKeep sentences short."
	if _, err := tmpFile.WriteString("  " + content + "  \n"); err != nil {
		t.Fatal(err)
	}
	tmpFile.Close()

	cfg := &Config{
		WritingStyle: WritingStyleConfig{
			Enabled:    true,
			FilePath:   tmpFile.Name(),
			Guidelines: "This should be ignored when FilePath is set",
		},
	}

	got := loadWritingStyle(cfg)
	if got != content {
		t.Errorf("loadWritingStyle() = %q, want %q", got, content)
	}
}

func TestLoadWritingStyle_FallbackToGuidelines(t *testing.T) {
	cfg := &Config{
		WritingStyle: WritingStyleConfig{
			Enabled:    true,
			FilePath:   "/nonexistent/path/style.txt",
			Guidelines: "Be concise and direct.",
		},
	}

	got := loadWritingStyle(cfg)
	if got != "Be concise and direct." {
		t.Errorf("loadWritingStyle() = %q, want %q", got, "Be concise and direct.")
	}
}

func TestLoadWritingStyle_GuidelinesOnly(t *testing.T) {
	cfg := &Config{
		WritingStyle: WritingStyleConfig{
			Enabled:    true,
			Guidelines: "Use formal language.",
		},
	}

	got := loadWritingStyle(cfg)
	if got != "Use formal language." {
		t.Errorf("loadWritingStyle() = %q, want %q", got, "Use formal language.")
	}
}

func TestLoadWritingStyle_Empty(t *testing.T) {
	cfg := &Config{
		WritingStyle: WritingStyleConfig{
			Enabled: true,
		},
	}

	got := loadWritingStyle(cfg)
	if got != "" {
		t.Errorf("loadWritingStyle() = %q, want empty string", got)
	}
}

// --- P21.4: Citation Injection tests ---

func TestCitationInjection(t *testing.T) {
	tests := []struct {
		name      string
		cfg       CitationConfig
		wantIn    string // substring that must appear in system prompt
		wantAbsent bool   // if true, wantIn must NOT appear
	}{
		{
			name:       "disabled",
			cfg:        CitationConfig{Enabled: false},
			wantIn:     "## Citation Rules",
			wantAbsent: true,
		},
		{
			name:   "default bracket format",
			cfg:    CitationConfig{Enabled: true},
			wantIn: "[source_name]",
		},
		{
			name:   "explicit bracket format",
			cfg:    CitationConfig{Enabled: true, Format: "bracket"},
			wantIn: "[source_name]",
		},
		{
			name:   "footnote format",
			cfg:    CitationConfig{Enabled: true, Format: "footnote"},
			wantIn: "[1] source_name",
		},
		{
			name:   "inline format",
			cfg:    CitationConfig{Enabled: true, Format: "inline"},
			wantIn: "(source: source_name)",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			prompt := "base prompt"

			// Simulate the citation injection logic from runTask.
			if tt.cfg.Enabled {
				citationFmt := tt.cfg.Format
				if citationFmt == "" {
					citationFmt = "bracket"
				}
				var citationRule string
				switch citationFmt {
				case "footnote":
					citationRule = "When using information from knowledge_search, note_search, or web_search results, " +
						"add numbered footnotes at the end of your response. Format: [1] source_name"
				case "inline":
					citationRule = "When using information from knowledge_search, note_search, or web_search results, " +
						"cite sources inline immediately after the relevant information. Format: (source: source_name)"
				default:
					citationRule = "When using information from knowledge_search, note_search, or web_search results, " +
						"cite the source at the end of your response. Format: [source_name]"
				}
				prompt += "\n\n## Citation Rules\n" + citationRule
			}

			if tt.wantAbsent {
				if strings.Contains(prompt, tt.wantIn) {
					t.Errorf("system prompt should NOT contain %q when citation is disabled", tt.wantIn)
				}
			} else {
				if !strings.Contains(prompt, tt.wantIn) {
					t.Errorf("system prompt should contain %q, got: %s", tt.wantIn, prompt)
				}
				if !strings.Contains(prompt, "## Citation Rules") {
					t.Error("system prompt should contain '## Citation Rules' header")
				}
			}
		})
	}
}

// --- P26: Agentic Loop Hardening Tests ---

func TestListFiltered_NilAllowed(t *testing.T) {
	cfg := newTestConfig()
	cfg.toolRegistry = NewToolRegistry(cfg)
	// With nil allowed, should return all tools.
	all := cfg.toolRegistry.List()
	filtered := cfg.toolRegistry.ListFiltered(nil)
	if len(filtered) != len(all) {
		t.Errorf("ListFiltered(nil) returned %d tools, want %d", len(filtered), len(all))
	}
}

func TestListFiltered_EmptyAllowed(t *testing.T) {
	cfg := newTestConfig()
	cfg.toolRegistry = NewToolRegistry(cfg)
	// With empty map, should return all tools.
	all := cfg.toolRegistry.List()
	filtered := cfg.toolRegistry.ListFiltered(map[string]bool{})
	if len(filtered) != len(all) {
		t.Errorf("ListFiltered(empty) returned %d tools, want %d", len(filtered), len(all))
	}
}

func TestListFiltered_PopulatedAllowed(t *testing.T) {
	reg := &ToolRegistry{tools: make(map[string]*ToolDef)}
	reg.Register(&ToolDef{Name: "alpha"})
	reg.Register(&ToolDef{Name: "beta"})
	reg.Register(&ToolDef{Name: "gamma"})

	allowed := map[string]bool{"alpha": true, "gamma": true}
	filtered := reg.ListFiltered(allowed)

	if len(filtered) != 2 {
		t.Fatalf("ListFiltered returned %d tools, want 2", len(filtered))
	}

	names := make(map[string]bool)
	for _, td := range filtered {
		names[td.Name] = true
	}
	if !names["alpha"] || !names["gamma"] {
		t.Errorf("expected alpha and gamma, got %v", names)
	}
	if names["beta"] {
		t.Error("beta should not be in filtered results")
	}
}

func TestTruncateToolOutput_BelowLimit(t *testing.T) {
	input := "short output"
	result := truncateToolOutput(input, 100)
	if result != input {
		t.Errorf("got %q, want %q", result, input)
	}
}

func TestTruncateToolOutput_AtLimit(t *testing.T) {
	input := strings.Repeat("x", 100)
	result := truncateToolOutput(input, 100)
	if result != input {
		t.Errorf("at-limit should not truncate, got len %d", len(result))
	}
}

func TestTruncateToolOutput_AboveLimit(t *testing.T) {
	input := strings.Repeat("x", 200)
	result := truncateToolOutput(input, 100)
	if !strings.HasPrefix(result, strings.Repeat("x", 100)) {
		t.Error("truncated output should start with first 100 chars")
	}
	if !strings.Contains(result, "[truncated: first 100 of 200 chars]") {
		t.Errorf("missing truncation notice, got: %s", result)
	}
}

func TestTruncateToolOutput_DefaultLimit(t *testing.T) {
	// Zero limit should default to 10240.
	input := strings.Repeat("a", 10240)
	result := truncateToolOutput(input, 0)
	if result != input {
		t.Error("10240 chars should not be truncated with default limit")
	}

	input2 := strings.Repeat("a", 10241)
	result2 := truncateToolOutput(input2, 0)
	if !strings.Contains(result2, "[truncated:") {
		t.Error("10241 chars should be truncated with default limit")
	}
}

func TestTokenAccumulation(t *testing.T) {
	// Test that accumulated metrics are set correctly on final result.
	// We simulate by constructing the scenario directly.
	var totalTokensIn, totalTokensOut int
	var totalCostUSD float64
	var totalProviderMs int64

	// Simulate 3 iterations of provider calls.
	iterations := []struct {
		tokIn, tokOut int
		cost          float64
		ms            int64
	}{
		{100, 50, 0.01, 200},
		{120, 60, 0.015, 180},
		{80, 40, 0.008, 150},
	}

	for _, it := range iterations {
		totalTokensIn += it.tokIn
		totalTokensOut += it.tokOut
		totalCostUSD += it.cost
		totalProviderMs += it.ms
	}

	finalResult := &ProviderResult{Output: "done"}
	finalResult.TokensIn = totalTokensIn
	finalResult.TokensOut = totalTokensOut
	finalResult.CostUSD = totalCostUSD
	finalResult.ProviderMs = totalProviderMs

	if finalResult.TokensIn != 300 {
		t.Errorf("TokensIn = %d, want 300", finalResult.TokensIn)
	}
	if finalResult.TokensOut != 150 {
		t.Errorf("TokensOut = %d, want 150", finalResult.TokensOut)
	}
	if finalResult.CostUSD < 0.032 || finalResult.CostUSD > 0.034 {
		t.Errorf("CostUSD = %f, want ~0.033", finalResult.CostUSD)
	}
	if finalResult.ProviderMs != 530 {
		t.Errorf("ProviderMs = %d, want 530", finalResult.ProviderMs)
	}
}
