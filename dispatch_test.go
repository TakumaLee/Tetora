package main

import (
	"context"
	"encoding/json"
	"os"
	"regexp"
	"strings"
	"testing"
	"time"
)

// --- newUUID tests ---

func TestNewUUID_NonEmpty(t *testing.T) {
	id := newUUID()
	if id == "" {
		t.Fatal("newUUID() returned empty string")
	}
}

func TestNewUUID_Unique(t *testing.T) {
	seen := make(map[string]bool)
	for i := 0; i < 100; i++ {
		id := newUUID()
		if seen[id] {
			t.Fatalf("newUUID() returned duplicate: %s", id)
		}
		seen[id] = true
	}
}

func TestNewUUID_Format(t *testing.T) {
	// UUID v4 pattern: xxxxxxxx-xxxx-4xxx-[89ab]xxx-xxxxxxxxxxxx
	pattern := regexp.MustCompile(`^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$`)
	for i := 0; i < 50; i++ {
		id := newUUID()
		if !pattern.MatchString(id) {
			t.Fatalf("newUUID() = %q does not match UUID v4 pattern", id)
		}
	}
}

// --- fillDefaults tests ---

func newTestConfig() *Config {
	return &Config{
		DefaultModel:          "sonnet",
		DefaultTimeout:        "15m",
		DefaultBudget:         5.0,
		DefaultPermissionMode: "acceptEdits",
	}
}

func TestFillDefaults_EmptyTask(t *testing.T) {
	cfg := newTestConfig()
	task := &Task{}
	fillDefaults(cfg, task)

	if task.ID == "" {
		t.Error("expected ID to be auto-generated")
	}
	if task.SessionID == "" {
		t.Error("expected SessionID to be auto-generated")
	}
	if task.Model != "sonnet" {
		t.Errorf("Model = %q, want %q", task.Model, "sonnet")
	}
	if task.Timeout != "15m" {
		t.Errorf("Timeout = %q, want %q", task.Timeout, "15m")
	}
	if task.Budget != 5.0 {
		t.Errorf("Budget = %v, want %v", task.Budget, 5.0)
	}
	if task.PermissionMode != "acceptEdits" {
		t.Errorf("PermissionMode = %q, want %q", task.PermissionMode, "acceptEdits")
	}
}

func TestFillDefaults_PresetFieldsPreserved(t *testing.T) {
	cfg := newTestConfig()
	task := &Task{
		ID:             "my-id",
		SessionID:      "my-session",
		Name:           "my-task",
		Model:          "opus",
		Timeout:        "30m",
		Budget:         10.0,
		PermissionMode: "bypassPermissions",
	}
	fillDefaults(cfg, task)

	if task.ID != "my-id" {
		t.Errorf("ID = %q, want %q", task.ID, "my-id")
	}
	if task.SessionID != "my-session" {
		t.Errorf("SessionID = %q, want %q", task.SessionID, "my-session")
	}
	if task.Name != "my-task" {
		t.Errorf("Name = %q, want %q", task.Name, "my-task")
	}
	if task.Model != "opus" {
		t.Errorf("Model = %q, want %q", task.Model, "opus")
	}
	if task.Timeout != "30m" {
		t.Errorf("Timeout = %q, want %q", task.Timeout, "30m")
	}
	if task.Budget != 10.0 {
		t.Errorf("Budget = %v, want %v", task.Budget, 10.0)
	}
	if task.PermissionMode != "bypassPermissions" {
		t.Errorf("PermissionMode = %q, want %q", task.PermissionMode, "bypassPermissions")
	}
}

func TestFillDefaults_IDAndSessionIDAutoGenerated(t *testing.T) {
	cfg := newTestConfig()
	task := &Task{}
	fillDefaults(cfg, task)

	if task.ID == "" {
		t.Error("expected ID to be auto-generated")
	}
	if task.SessionID == "" {
		t.Error("expected SessionID to be auto-generated")
	}
	if task.ID == task.SessionID {
		t.Error("ID and SessionID should be different UUIDs")
	}
}

func TestFillDefaults_WorkdirTildeExpansion(t *testing.T) {
	cfg := newTestConfig()
	task := &Task{Workdir: "~/projects/test"}
	fillDefaults(cfg, task)

	home, _ := os.UserHomeDir()
	if strings.HasPrefix(task.Workdir, "~/") {
		t.Errorf("Workdir still has ~/: %q", task.Workdir)
	}
	if !strings.HasPrefix(task.Workdir, home) {
		t.Errorf("Workdir = %q, expected prefix %q", task.Workdir, home)
	}
	if !strings.HasSuffix(task.Workdir, "projects/test") {
		t.Errorf("Workdir = %q, expected suffix %q", task.Workdir, "projects/test")
	}
}

func TestFillDefaults_EmptyNameAutoGenerated(t *testing.T) {
	cfg := newTestConfig()
	task := &Task{}
	fillDefaults(cfg, task)

	expectedPrefix := "task-" + task.ID[:8]
	if task.Name != expectedPrefix {
		t.Errorf("Name = %q, want %q", task.Name, expectedPrefix)
	}
}

func TestFillDefaults_DefaultWorkdirFromConfig(t *testing.T) {
	cfg := newTestConfig()
	cfg.DefaultWorkdir = "/tmp/tetora-test-workdir"
	task := &Task{}
	fillDefaults(cfg, task)

	if task.Workdir != "/tmp/tetora-test-workdir" {
		t.Errorf("Workdir = %q, want %q", task.Workdir, "/tmp/tetora-test-workdir")
	}
}

// --- parseClaudeOutput tests ---

func TestParseClaudeOutput_SuccessJSON(t *testing.T) {
	co := claudeOutput{
		Type:       "result",
		Result:     "Task completed successfully.",
		IsError:    false,
		DurationMs: 5000,
		CostUSD:    0.12,
		SessionID:  "sess-abc",
	}
	stdout, _ := json.Marshal(co)

	r := parseClaudeOutput(stdout, nil, 0)

	if r.Status != "success" {
		t.Errorf("Status = %q, want %q", r.Status, "success")
	}
	if r.Output != "Task completed successfully." {
		t.Errorf("Output = %q, want %q", r.Output, "Task completed successfully.")
	}
	if r.CostUSD != 0.12 {
		t.Errorf("CostUSD = %v, want %v", r.CostUSD, 0.12)
	}
	if r.SessionID != "sess-abc" {
		t.Errorf("SessionID = %q, want %q", r.SessionID, "sess-abc")
	}
	if r.Error != "" {
		t.Errorf("Error = %q, want empty", r.Error)
	}
	if r.ExitCode != 0 {
		t.Errorf("ExitCode = %d, want 0", r.ExitCode)
	}
}

func TestParseClaudeOutput_ErrorJSON(t *testing.T) {
	co := claudeOutput{
		Type:    "result",
		Subtype: "rate_limit",
		Result:  "Rate limited",
		IsError: true,
		CostUSD: 0.01,
	}
	stdout, _ := json.Marshal(co)

	r := parseClaudeOutput(stdout, nil, 0)

	if r.Status != "error" {
		t.Errorf("Status = %q, want %q", r.Status, "error")
	}
	if r.Error != "rate_limit" {
		t.Errorf("Error = %q, want %q", r.Error, "rate_limit")
	}
	if r.Output != "Rate limited" {
		t.Errorf("Output = %q, want %q", r.Output, "Rate limited")
	}
}

func TestParseClaudeOutput_InvalidJSONFallback(t *testing.T) {
	stdout := []byte("some raw text output")

	r := parseClaudeOutput(stdout, nil, 0)

	if r.Status != "success" {
		t.Errorf("Status = %q, want %q", r.Status, "success")
	}
	if r.Output != "some raw text output" {
		t.Errorf("Output = %q, want %q", r.Output, "some raw text output")
	}
}

func TestParseClaudeOutput_NonZeroExitInvalidJSON(t *testing.T) {
	stdout := []byte("partial output")
	stderr := []byte("something went wrong")

	r := parseClaudeOutput(stdout, stderr, 1)

	if r.Status != "error" {
		t.Errorf("Status = %q, want %q", r.Status, "error")
	}
	if r.ExitCode != 1 {
		t.Errorf("ExitCode = %d, want 1", r.ExitCode)
	}
	if r.Output != "partial output" {
		t.Errorf("Output = %q, want %q", r.Output, "partial output")
	}
	if r.Error != "something went wrong" {
		t.Errorf("Error = %q, want %q", r.Error, "something went wrong")
	}
}

func TestParseClaudeOutput_LongStderrTruncated(t *testing.T) {
	stdout := []byte("out")
	stderr := []byte(strings.Repeat("x", 600))

	r := parseClaudeOutput(stdout, stderr, 1)

	if len(r.Error) != 500 {
		t.Errorf("Error length = %d, want 500 (truncated)", len(r.Error))
	}
}

func TestParseClaudeOutput_EmptyStdout(t *testing.T) {
	r := parseClaudeOutput(nil, nil, 0)

	if r.Status != "success" {
		t.Errorf("Status = %q, want %q", r.Status, "success")
	}
	if r.Output != "" {
		t.Errorf("Output = %q, want empty", r.Output)
	}
}

func TestParseClaudeOutput_ValidJSONIgnoresExitCode(t *testing.T) {
	// When JSON is valid, the parsed status takes precedence.
	co := claudeOutput{
		Type:    "result",
		Result:  "done",
		IsError: false,
		CostUSD: 0.05,
	}
	stdout, _ := json.Marshal(co)

	r := parseClaudeOutput(stdout, []byte("some stderr"), 1)

	// Valid JSON means we use the JSON-parsed status, which is success.
	if r.Status != "success" {
		t.Errorf("Status = %q, want %q", r.Status, "success")
	}
	if r.ExitCode != 1 {
		t.Errorf("ExitCode = %d, want 1", r.ExitCode)
	}
}

// --- buildSummary tests ---

func TestBuildSummary_AllSuccess(t *testing.T) {
	dr := &DispatchResult{
		DurationMs: 5000,
		TotalCost:  0.25,
		Tasks: []TaskResult{
			{Status: "success", CostUSD: 0.10},
			{Status: "success", CostUSD: 0.15},
		},
	}
	summary := buildSummary(dr)

	if !strings.Contains(summary, "2/2") {
		t.Errorf("summary = %q, expected to contain %q", summary, "2/2")
	}
	if !strings.Contains(summary, "$0.25") {
		t.Errorf("summary = %q, expected to contain %q", summary, "$0.25")
	}
	if !strings.Contains(summary, "5s") {
		t.Errorf("summary = %q, expected to contain %q", summary, "5s")
	}
}

func TestBuildSummary_MixedResults(t *testing.T) {
	dr := &DispatchResult{
		DurationMs: 12800,
		TotalCost:  0.50,
		Tasks: []TaskResult{
			{Status: "success", CostUSD: 0.20},
			{Status: "error", CostUSD: 0.10},
			{Status: "timeout", CostUSD: 0.20},
		},
	}
	summary := buildSummary(dr)

	if !strings.Contains(summary, "1/3") {
		t.Errorf("summary = %q, expected to contain %q", summary, "1/3")
	}
	if !strings.Contains(summary, "$0.50") {
		t.Errorf("summary = %q, expected to contain %q", summary, "$0.50")
	}
	if !strings.Contains(summary, "13s") {
		t.Errorf("summary = %q, expected to contain %q", summary, "13s")
	}
}

func TestBuildSummary_NoTasks(t *testing.T) {
	dr := &DispatchResult{
		DurationMs: 100,
		TotalCost:  0.0,
		Tasks:      []TaskResult{},
	}
	summary := buildSummary(dr)

	if !strings.Contains(summary, "0/0") {
		t.Errorf("summary = %q, expected to contain %q", summary, "0/0")
	}
}

func TestBuildSummary_AllFailed(t *testing.T) {
	dr := &DispatchResult{
		DurationMs: 3000,
		TotalCost:  0.10,
		Tasks: []TaskResult{
			{Status: "error"},
			{Status: "error"},
		},
	}
	summary := buildSummary(dr)

	if !strings.Contains(summary, "0/2") {
		t.Errorf("summary = %q, expected to contain %q", summary, "0/2")
	}
}

// --- newDispatchState tests ---

func TestNewDispatchState(t *testing.T) {
	s := newDispatchState()
	if s == nil {
		t.Fatal("newDispatchState() returned nil")
	}
	if s.running == nil {
		t.Error("running map should be initialized")
	}
	if s.active {
		t.Error("new state should not be active")
	}
	if len(s.finished) != 0 {
		t.Error("new state should have no finished tasks")
	}
}

// --- dispatchState.statusJSON tests ---

func TestStatusJSON_Idle(t *testing.T) {
	s := newDispatchState()
	b := s.statusJSON()

	var out map[string]any
	if err := json.Unmarshal(b, &out); err != nil {
		t.Fatalf("statusJSON returned invalid JSON: %v", err)
	}
	if out["status"] != "idle" {
		t.Errorf("status = %q, want %q", out["status"], "idle")
	}
}

func TestStatusJSON_Done(t *testing.T) {
	s := newDispatchState()
	s.finished = []TaskResult{
		{ID: "abc", Name: "test", Status: "success"},
	}
	b := s.statusJSON()

	var out map[string]any
	if err := json.Unmarshal(b, &out); err != nil {
		t.Fatalf("statusJSON returned invalid JSON: %v", err)
	}
	if out["status"] != "done" {
		t.Errorf("status = %q, want %q", out["status"], "done")
	}
	completed, ok := out["completed"].(float64)
	if !ok || completed != 1 {
		t.Errorf("completed = %v, want 1", out["completed"])
	}
}

// --- sanitizePrompt tests ---

func TestSanitizePrompt_NullBytes(t *testing.T) {
	input := "hello\x00world"
	got := sanitizePrompt(input, 0)
	if strings.Contains(got, "\x00") {
		t.Error("sanitizePrompt should strip null bytes")
	}
	if got != "helloworld" {
		t.Errorf("sanitizePrompt = %q, want %q", got, "helloworld")
	}
}

func TestSanitizePrompt_ANSIEscapes(t *testing.T) {
	input := "hello \x1b[31mred\x1b[0m world"
	got := sanitizePrompt(input, 0)
	if got != "hello red world" {
		t.Errorf("sanitizePrompt = %q, want %q", got, "hello red world")
	}
}

func TestSanitizePrompt_MaxLength(t *testing.T) {
	input := strings.Repeat("a", 200)
	got := sanitizePrompt(input, 100)
	if len(got) != 100 {
		t.Errorf("sanitizePrompt length = %d, want 100", len(got))
	}
}

func TestSanitizePrompt_DefaultMaxLength(t *testing.T) {
	input := strings.Repeat("a", 200000)
	got := sanitizePrompt(input, 0)
	if len(got) != 102400 {
		t.Errorf("sanitizePrompt default max = %d, want 102400", len(got))
	}
}

func TestSanitizePrompt_CleanInput(t *testing.T) {
	input := "Normal prompt text with no special chars."
	got := sanitizePrompt(input, 0)
	if got != input {
		t.Errorf("sanitizePrompt should not modify clean input")
	}
}

func TestSanitizePrompt_Empty(t *testing.T) {
	got := sanitizePrompt("", 0)
	if got != "" {
		t.Errorf("sanitizePrompt(\"\") = %q, want \"\"", got)
	}
}

func TestSanitizePrompt_ComplexANSI(t *testing.T) {
	// Various ANSI sequences.
	input := "\x1b[1mbold\x1b[0m \x1b[38;5;200mcolor\x1b[0m"
	got := sanitizePrompt(input, 0)
	if strings.Contains(got, "\x1b") {
		t.Errorf("sanitizePrompt should strip all ANSI: %q", got)
	}
}

func TestStatusJSON_Dispatching(t *testing.T) {
	s := newDispatchState()
	s.active = true
	s.startAt = time.Now()
	s.running["test-id"] = &taskState{
		task:    Task{ID: "test-id-1234", Name: "running-task", Model: "opus", Timeout: "10m"},
		startAt: time.Now(),
	}
	b := s.statusJSON()

	var out map[string]any
	if err := json.Unmarshal(b, &out); err != nil {
		t.Fatalf("statusJSON returned invalid JSON: %v", err)
	}
	if out["status"] != "dispatching" {
		t.Errorf("status = %q, want %q", out["status"], "dispatching")
	}
	running, ok := out["running"].(float64)
	if !ok || running != 1 {
		t.Errorf("running = %v, want 1", out["running"])
	}
	if _, exists := out["elapsed"]; !exists {
		t.Error("expected elapsed field when dispatching")
	}
}

// --- failedTask tests ---

func TestNewDispatchState_FailedTasksInitialized(t *testing.T) {
	s := newDispatchState()
	if s.failedTasks == nil {
		t.Error("failedTasks map should be initialized")
	}
	if len(s.failedTasks) != 0 {
		t.Error("failedTasks map should be empty")
	}
}

func TestListFailedTasks_Empty(t *testing.T) {
	s := newDispatchState()
	tasks := listFailedTasks(s)
	if len(tasks) != 0 {
		t.Errorf("listFailedTasks on empty state = %d, want 0", len(tasks))
	}
}

func TestListFailedTasks_WithEntries(t *testing.T) {
	s := newDispatchState()
	s.failedTasks["task-1"] = &failedTask{
		task:     Task{ID: "task-1", Name: "failed-job", Prompt: "do something", Role: "琉璃", Source: "route:telegram"},
		failedAt: time.Now(),
		errorMsg: "rate limited",
	}
	s.failedTasks["task-2"] = &failedTask{
		task:     Task{ID: "task-2", Name: "timeout-job", Prompt: "do something else", Source: "dispatch"},
		failedAt: time.Now(),
		errorMsg: "timed out after 5m",
	}

	tasks := listFailedTasks(s)
	if len(tasks) != 2 {
		t.Errorf("listFailedTasks = %d entries, want 2", len(tasks))
	}

	// Check fields are populated.
	found := false
	for _, ft := range tasks {
		if ft.ID == "task-1" {
			found = true
			if ft.Name != "failed-job" {
				t.Errorf("Name = %q, want %q", ft.Name, "failed-job")
			}
			if ft.Role != "琉璃" {
				t.Errorf("Role = %q, want %q", ft.Role, "琉璃")
			}
			if ft.Error != "rate limited" {
				t.Errorf("Error = %q, want %q", ft.Error, "rate limited")
			}
			if ft.FailedAt == "" {
				t.Error("FailedAt should not be empty")
			}
		}
	}
	if !found {
		t.Error("task-1 not found in listFailedTasks output")
	}
}

func TestListFailedTasks_PromptTruncated(t *testing.T) {
	s := newDispatchState()
	longPrompt := strings.Repeat("a", 200)
	s.failedTasks["task-1"] = &failedTask{
		task:     Task{ID: "task-1", Name: "test", Prompt: longPrompt},
		failedAt: time.Now(),
		errorMsg: "error",
	}

	tasks := listFailedTasks(s)
	if len(tasks) != 1 {
		t.Fatalf("expected 1 task, got %d", len(tasks))
	}
	if len(tasks[0].Prompt) > 104 { // 100 + "..."
		t.Errorf("prompt should be truncated, got length %d", len(tasks[0].Prompt))
	}
}

func TestCleanupFailedTasks_RemovesExpired(t *testing.T) {
	s := newDispatchState()

	// Add a fresh task.
	s.failedTasks["fresh"] = &failedTask{
		task:     Task{ID: "fresh", Name: "fresh-task"},
		failedAt: time.Now(),
		errorMsg: "error",
	}

	// Add an expired task (31 minutes ago).
	s.failedTasks["expired"] = &failedTask{
		task:     Task{ID: "expired", Name: "expired-task"},
		failedAt: time.Now().Add(-31 * time.Minute),
		errorMsg: "old error",
	}

	cleanupFailedTasks(s)

	if _, ok := s.failedTasks["fresh"]; !ok {
		t.Error("fresh task should still exist after cleanup")
	}
	if _, ok := s.failedTasks["expired"]; ok {
		t.Error("expired task should be removed after cleanup")
	}
}

func TestCleanupFailedTasks_KeepsNonExpired(t *testing.T) {
	s := newDispatchState()

	// Add tasks at various ages below the TTL.
	s.failedTasks["t1"] = &failedTask{
		task:     Task{ID: "t1"},
		failedAt: time.Now().Add(-5 * time.Minute),
		errorMsg: "e",
	}
	s.failedTasks["t2"] = &failedTask{
		task:     Task{ID: "t2"},
		failedAt: time.Now().Add(-29 * time.Minute),
		errorMsg: "e",
	}

	cleanupFailedTasks(s)

	if len(s.failedTasks) != 2 {
		t.Errorf("cleanup removed non-expired tasks: got %d, want 2", len(s.failedTasks))
	}
}

func TestRetryTask_NotFound(t *testing.T) {
	s := newDispatchState()
	cfg := newTestConfig()

	sem := make(chan struct{}, 1)
	_, err := retryTask(context.Background(), cfg, "nonexistent", s, sem)
	if err == nil {
		t.Fatal("expected error for non-existent task")
	}
	if !strings.Contains(err.Error(), "not found") {
		t.Errorf("error = %q, want to contain 'not found'", err.Error())
	}
}

func TestRerouteTask_NotFound(t *testing.T) {
	s := newDispatchState()
	cfg := newTestConfig()
	cfg.SmartDispatch.Enabled = true

	sem := make(chan struct{}, 1)
	_, err := rerouteTask(context.Background(), cfg, "nonexistent", s, sem)
	if err == nil {
		t.Fatal("expected error for non-existent task")
	}
	if !strings.Contains(err.Error(), "not found") {
		t.Errorf("error = %q, want to contain 'not found'", err.Error())
	}
}

func TestRerouteTask_SmartDispatchDisabled(t *testing.T) {
	s := newDispatchState()
	cfg := newTestConfig()
	cfg.SmartDispatch.Enabled = false

	// Add a failed task.
	s.failedTasks["task-1"] = &failedTask{
		task:     Task{ID: "task-1", Name: "test", Prompt: "do something"},
		failedAt: time.Now(),
		errorMsg: "error",
	}

	sem := make(chan struct{}, 1)
	_, err := rerouteTask(context.Background(), cfg, "task-1", s, sem)
	if err == nil {
		t.Fatal("expected error when smart dispatch is disabled")
	}
	if !strings.Contains(err.Error(), "not enabled") {
		t.Errorf("error = %q, want to contain 'not enabled'", err.Error())
	}
}

func TestFailedTaskInfo_JSONSerialization(t *testing.T) {
	info := failedTaskInfo{
		ID:       "abc-123",
		Name:     "test-task",
		Prompt:   "do something",
		Role:     "琉璃",
		Source:   "telegram",
		Error:    "timed out",
		FailedAt: "2026-02-22T10:00:00Z",
	}

	data, err := json.Marshal(info)
	if err != nil {
		t.Fatalf("json.Marshal failed: %v", err)
	}

	var decoded failedTaskInfo
	if err := json.Unmarshal(data, &decoded); err != nil {
		t.Fatalf("json.Unmarshal failed: %v", err)
	}

	if decoded.ID != info.ID {
		t.Errorf("ID = %q, want %q", decoded.ID, info.ID)
	}
	if decoded.Name != info.Name {
		t.Errorf("Name = %q, want %q", decoded.Name, info.Name)
	}
	if decoded.Role != info.Role {
		t.Errorf("Role = %q, want %q", decoded.Role, info.Role)
	}
	if decoded.Error != info.Error {
		t.Errorf("Error = %q, want %q", decoded.Error, info.Error)
	}
	if decoded.FailedAt != info.FailedAt {
		t.Errorf("FailedAt = %q, want %q", decoded.FailedAt, info.FailedAt)
	}
}
